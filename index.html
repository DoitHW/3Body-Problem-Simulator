<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Simulador Tres Cuerpos – Corrección Visualización</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background-color: #050510; 
      font-family: 'Roboto Condensed', Arial, sans-serif; 
      color: #eee; 
      height: 100%;
      touch-action: none;
    }
    canvas {
      display: block; 
      background: radial-gradient(ellipse at center, #1a1a2e 0%, #050510 100%);
      width: 100%; 
      height: 100%;
    }
    /* Botón de toggle fuera del panel */
    #btnTogglePanel {
      position: fixed; 
      top: 20px; 
      left: 20px;
      z-index: 20; 
      padding: 10px 20px;
      border: 1px solid #555; 
      border-radius: 5px; 
      background-color: #333;
      color: #fff; 
      font-size: 15px; 
      cursor: pointer;
      transition: background-color 0.3s ease; 
    }
    #btnTogglePanel:hover {
      background-color: #555; 
    }
    #controlPanel {
      position: fixed; 
      top: 20px; 
      right: 20px;
      background: rgba(30,30,40,0.95); 
      padding: 20px;
      border-radius: 10px; 
      width: 400px; 
      z-index: 10;
      max-height: 90vh; 
      overflow-y: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.5); 
      display: flex;
      flex-direction: column;
    }
    #panelHeader {
      display: flex; 
      justify-content: center; 
      align-items: center;
      margin-bottom: 15px; 
      border-bottom: 1px solid #555; 
      padding-bottom: 10px;
    }
    #panelHeader h2 { 
      margin: 0; 
      font-size: 24px; 
      font-weight: normal; 
    }
    /* Contenedor para toggle de zoom automático */
    #globalZoomToggleContainer {
      margin-top: 12px; 
      display: none;
    }
    #globalZoomToggleContainer button {
      width: 100%; 
      padding: 10px;
      border: 1px solid #555; 
      border-radius: 5px; 
      background-color: #444;
      color: #fff; 
      font-size: 15px; 
      cursor: pointer;
      transition: background-color 0.3s ease; 
    }
    #globalZoomToggleContainer button:hover {
      background-color: #666; 
    }
    #controlPanel label {
      display: block; 
      margin-top: 10px; 
      font-size: 15px; 
      color: #ddd; 
    }
    #controlPanel input[type="number"],
    #controlPanel input[type="color"],
    #controlPanel input[type="range"],
    #controlPanel select,
    #controlPanel input[type="text"] {
      width: calc(100% - 10px); 
      padding: 8px; 
      margin-top: 6px;
      margin-bottom: 6px; 
      box-sizing: border-box; 
      font-size: 14px; 
      border: 1px solid #666; 
      border-radius: 4px;
      background-color: #222; 
      color: #eee; 
    }
    #controlPanel button {
      width: 49%; 
      padding: 10px; 
      margin-top: 15px;
      border: none; 
      border-radius: 5px; 
      cursor: pointer; 
      font-size: 15px; 
      background-color: #555; 
      color: #fff;
      transition: background-color 0.3s ease; 
    }
    #controlPanel button:hover {
      background-color: #777; 
    }
    .btn-container { 
      display: flex; 
      justify-content: space-between; 
      margin-top: 5px; 
    }
    #extraInfo {
      margin-top: 12px; 
      padding: 10px; 
      background: rgba(0,0,0,0.8); 
      border-radius: 5px; 
      font-size: 13px; 
      color: #ccc; 
    }
    #infoModal {
      display: none; 
      position: fixed; 
      top: 50%; 
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30,30,40,0.98); 
      padding: 30px;
      border-radius: 12px; 
      z-index: 30; 
      width: 85%; 
      max-height: 85vh; 
      overflow-y: auto;
      box-shadow: 0 8px 16px rgba(0,0,0,0.7); 
    }
    #infoModal h2 { 
      text-align: center; 
      font-size: 28px; 
      margin-bottom: 20px; 
      font-weight: normal; 
    }
    #infoModal p { 
      font-size: 15px; 
      line-height: 1.6; 
      color: #ddd; 
    }
    #btnCerrarInfo {
      display: block; 
      margin: 20px auto 0 auto; 
      padding: 10px 20px;
      border: none; 
      border-radius: 5px; 
      background-color: #666;
      color: #fff; 
      cursor: pointer;
      font-size: 15px; 
      transition: background-color 0.3s ease; 
    }
    #btnCerrarInfo:hover {
      background-color: #888; 
    }
    #listaCuerpos {
      margin-top: 12px; 
      border: 1px solid #555; 
      border-radius: 6px; 
      padding: 10px;
      background-color: #1a1a2e; 
    }
    .cuerpoItem {
      border-bottom: 1px solid #555;
      padding: 15px 0; 
      margin-bottom: 10px;
    }
    .cuerpoItem:last-child { 
      border-bottom: none; 
    }
    .campo { 
      margin-top: 10px; 
    }
    .campo label { 
      font-size: 13px; 
      color: #ccc; 
    }
    .campo input { 
      width: calc(100% - 8px); 
      padding: 8px; 
      font-size: 13px; 
      border: 1px solid #666; 
      border-radius: 4px;
      background-color: #222; 
      color: #eee; 
    }
    .btnEliminar {
      background-color: #c0392b; 
      color: #fff; 
      border: none; 
      border-radius: 4px;
      padding: 6px 12px; 
      cursor: pointer; 
      font-size: 13px; 
      margin-top: 8px; 
      transition: background-color 0.3s ease; 
    }
    .btnEliminar:hover {
      background-color: #e74c3c; 
    }
    #formAgregar {
      display: none; 
      position: fixed; 
      top: 50%; 
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30,30,40,0.95); 
      padding: 30px;
      border-radius: 12px; 
      z-index: 20; 
      width: 350px; 
      box-shadow: 0 8px 16px rgba(0,0,0,0.7); 
    }
    #formAgregar h3 { 
      text-align: center; 
      margin-top: 0; 
      margin-bottom: 20px; 
      font-size: 24px; 
      font-weight: normal; 
    }
    #formAgregar label { 
      display: block; 
      margin-top: 12px; 
      font-size: 15px; 
      color: #ddd; 
    }
    #formAgregar input[type="number"],
    #formAgregar input[type="color"] {
      width: calc(100% - 10px); 
      padding: 8px; 
      margin-top: 6px;
      margin-bottom: 10px; 
      box-sizing: border-box; 
      font-size: 14px; 
      border: 1px solid #666; 
      border-radius: 4px;
      background-color: #222; 
      color: #eee; 
    }
    #formAgregar button {
      width: 100%; 
      padding: 10px; 
      margin-top: 15px;
      border: none; 
      border-radius: 5px; 
      cursor: pointer; 
      font-size: 15px; 
      background-color: #555; 
      color: #fff;
      transition: background-color 0.3s ease; 
    }
    #formAgregar button:hover {
      opacity: 0.9;
      background-color: #777; 
    }
    #formAgregar button#btnCancelarAgregar {
      background-color: #777; 
    }
    #formAgregar button#btnCancelarAgregar:hover {
      background-color: #999; 
    }
    .scrollable-section {
      max-height: 400px; 
      overflow-y: auto;
      margin-top: 10px;
      border: 1px solid #555;
      border-radius: 6px;
      padding: 10px;
      background-color: #1a1a2e; 
    }
    .scrollable-section h3 {
      margin-top: 0; 
      margin-bottom: 10px;
    }
    .scrollable-section #listaCuerpos {
      border: none; 
      padding: 0; 
      background-color: transparent; 
      margin-top: 0; 
    }
    @media (max-width: 600px) {
      #controlPanel { 
        width: 95%; 
        right: 2.5%; 
        top: 15px; 
        padding: 15px; 
      }
      #infoModal, #formAgregar {
        width: 90%; 
        padding: 20px; 
      }
      #infoModal h2, #formAgregar h3 {
        font-size: 22px; 
      }
      #infoModal p, #formAgregar label,
      #controlPanel label,
      #controlPanel button, #btnTogglePanel,
      #globalZoomToggleContainer button,
      .btnEliminar, #formAgregar button,
      .campo label, .campo input {
        font-size: 14px; 
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <!-- Botón de toggle siempre visible -->
  <button id="btnTogglePanel">Ocultar Panel</button>
  
  <div id="controlPanel" style="display:block;"> 
    <div id="panelHeader">
      <h2>Controles</h2>
    </div>
    <div class="btn-container">
      <button id="btnPausar">Pausar</button>
      <button id="btnReiniciar">Reiniciar</button>
    </div>
    <div class="btn-container">
      <button id="btnRestablecer" style="width:98%;">Restablecer por defecto</button>
    </div>
    
    <label for="configSelect">Configuración:</label>
    <select id="configSelect">
      <option value="personalizada" selected>Personalizada</option>
      <option value="lagrange">Lagrange (Triángulo)</option>
      <option value="figura8">El Ocho</option>
      <option value="euler">Euler (Colineal)</option>
      <option value="butterfly">Butterfly‑1</option>
    </select>
    <div id="extraInfo"></div>
    
    <label for="dtRange">Paso temporal (dt): <span id="dtValor">0.001</span></label>
    <input type="range" id="dtRange" min="0.0001" max="0.01" step="0.0001" value="0.001">
    
    <label for="scaleRange">Escala: <span id="scaleValor">1</span></label>
    <input type="range" id="scaleRange" min="0.1" max="5" step="0.1" value="1">
    
    <label for="speedRange">Velocidad: <span id="speedValor">1</span>x</label>
    <input type="range" id="speedRange" min="0.1" max="50" step="0.1" value="1">
    
    <label for="trackSelect">Tracking Cámara:</label>
    <select id="trackSelect">
      <option value="none">Ninguno</option>
    </select>
    <!-- Contenedor para el toggle de zoom automático en modo global -->
    <div id="globalZoomToggleContainer">
      <button id="btnToggleAutoZoom">Desactivar Zoom Automático</button>
    </div>
    
    <div class="btn-container">
      <button id="btnInfo" style="width:100%;">Información</button>
    </div>
    <div class="scrollable-section">
      <h3>Cuerpos</h3>
      <div id="listaCuerpos"></div>
    </div>
    <button id="btnAgregar" style="width:100%;">Añadir Cuerpo</button>
    <small style="color:#aaa; display:block; margin-top:10px;">Arrastra los cuerpos o, si no tocas ninguno, arrastra para mover la cámara.</small>
  </div>
  
  <div id="infoModal">
    <h2>Información sobre las Configuraciones</h2>
    <p><strong>Lagrange:</strong> Tres masas iguales formando un triángulo equilátero en rotación.</p>
    <p><strong>El Ocho:</strong> Solución de Chenciner–Montgomery donde tres masas siguen una trayectoria en forma de 8.</p>
    <p><strong>Euler:</strong> Tres masas en configuración colineal con movimiento periódico.</p>
    <p><strong>Butterfly‑1:</strong> Solución de Šuvakov–Dmitrašinović con trayectoria tipo mariposa.</p>
    <button id="btnCerrarInfo" style="width: 100%">Cerrar</button>
  </div>
  
  <div id="formAgregar">
    <h3>Nuevo Cuerpo</h3>
    <label for="nuevaMasa">Masa:</label>
    <input type="number" id="nuevaMasa" value="1" step="0.1">
    <label for="nuevaVx">Velocidad X:</label>
    <input type="number" id="nuevaVx" value="0" step="0.1">
    <label for="nuevaVy">Velocidad Y:</label>
    <input type="number" id="nuevaVy" value="0" step="0.1">
    <label for="nuevoPosX">Posición X:</label>
    <input type="number" id="nuevoPosX" value="0" step="1">
    <label for="nuevoPosY">Posición Y:</label>
    <input type="number" id="nuevoPosY" value="0" step="1">
    <label for="nuevoColor">Color:</label>
    <input type="color" id="nuevoColor" value="#ffffff">
    <button id="btnConfirmarAgregar">Agregar</button>
    <button id="btnCancelarAgregar" style="background-color:#777;">Cancelar</button>
  </div>
  
  <script>
    (function(){
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      
      // Convertir coordenadas de pantalla a mundo (eje Y normal: positivos hacia arriba)
      function screenToWorld(screenX, screenY) {
        return {
          x: (screenX - canvas.width/2) / sim.scale + sim.centerX,
          y: (canvas.height/2 - screenY) / sim.scale + sim.centerY
        };
      }
      
      let isPinching = false, initialPinchDistance = 0, initialScale = 0;
      let initialCenter = {x: 0, y: 0};
      
      let draggingIndex = null, draggingCamera = false;
      let lastMouseX = 0, lastMouseY = 0;
      let lastTouchX = 0, lastTouchY = 0;
      
      const btnTogglePanel = document.getElementById('btnTogglePanel');
      btnTogglePanel.addEventListener('click', () => {
        const panel = document.getElementById('controlPanel');
        if (panel.style.display === "none") {
          panel.style.display = "block";
          btnTogglePanel.textContent = "Ocultar Panel";
        } else {
          panel.style.display = "none";
          btnTogglePanel.textContent = "Mostrar Panel";
        }
      });
      
      canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const worldPos = screenToWorld(mouseX, mouseY);
        draggingIndex = null;
        let sobreCuerpo = false;
        sim.bodies.forEach((b, i) => {
          const dx = worldPos.x - b.x;
          const dy = worldPos.y - b.y;
          if (Math.hypot(dx, dy) < b.radius * 2) {
            draggingIndex = i;
            sobreCuerpo = true;
          }
        });
        if (!sobreCuerpo && document.getElementById('trackSelect').value === "none") {
          draggingCamera = true;
        }
        lastMouseX = mouseX;
        lastMouseY = mouseY;
      });
      
      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        if (draggingIndex !== null) {
          const worldPos = screenToWorld(mouseX, mouseY);
          const body = sim.bodies[draggingIndex];
          body.x = worldPos.x;
          body.y = worldPos.y;
          body.vx = (mouseX - lastMouseX) / (sim.scale * sim.dt * 10);
          body.vy = (mouseY - lastMouseY) / (sim.scale * sim.dt * 10);
          body.trail = [];
        } else if (draggingCamera) {
          const dx = mouseX - lastMouseX;
	  const dy = mouseY - lastMouseY;
	  sim.centerX -= dx / sim.scale;
	  sim.centerY += dy / sim.scale;
        }
        lastMouseX = mouseX;
        lastMouseY = mouseY;
      });
      
      canvas.addEventListener('mouseup', () => { draggingIndex = null; draggingCamera = false; });
      canvas.addEventListener('mouseleave', () => { draggingIndex = null; draggingCamera = false; });
      
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if(e.touches.length === 1) {
          const rect = canvas.getBoundingClientRect();
          const touch = e.touches[0];
          const touchX = touch.clientX - rect.left;
          const touchY = touch.clientY - rect.top;
          const worldPos = screenToWorld(touchX, touchY);
          draggingIndex = null;
          let sobreCuerpo = false;
          sim.bodies.forEach((b, i) => {
            const dx = worldPos.x - b.x;
            const dy = worldPos.y - b.y;
            if (Math.hypot(dx, dy) < b.radius * 2) {
              draggingIndex = i;
              sobreCuerpo = true;
            }
          });
          if (!sobreCuerpo && document.getElementById('trackSelect').value === "none") {
            draggingCamera = true;
          }
          lastTouchX = touch.clientX;
          lastTouchY = touch.clientY;
        } else if(e.touches.length === 2) {
          isPinching = true;
          initialPinchDistance = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
          initialScale = sim.scale;
          initialCenter = {x: sim.centerX, y: sim.centerY};
        }
      });
      
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if(e.touches.length === 1 && !isPinching) {
          const rect = canvas.getBoundingClientRect();
          const touch = e.touches[0];
          const touchX = touch.clientX - rect.left;
          const touchY = touch.clientY - rect.top;
          if (draggingIndex !== null) {
            const worldPos = screenToWorld(touchX, touchY);
            const body = sim.bodies[draggingIndex];
            body.x = worldPos.x;
            body.y = worldPos.y;
            body.vx = 0;
            body.vy = 0;
            body.trail = [];
          } else if (draggingCamera) {
            const dx = touch.clientX - lastTouchX;
	  const dy = touch.clientY - lastTouchY;
	  sim.centerX -= dx / sim.scale;
	  sim.centerY += dy / sim.scale;
          }
          lastTouchX = touch.clientX;
          lastTouchY = touch.clientY;
        } else if(e.touches.length === 2) {
          const currentPinchDistance = Math.hypot(
            e.touches[0].clientX - e.touches[1].clientX,
            e.touches[0].clientY - e.touches[1].clientY
          );
          const scaleFactor = currentPinchDistance / initialPinchDistance;
          sim.targetScale = (sim._requiredGlobalScale || sim.factorBase) * sim.userScaleFactor * scaleFactor;
          const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
          const rect = canvas.getBoundingClientRect();
          const canvasMid = { x: rect.width/2, y: rect.height/2 };
          const dx = (midX - canvasMid.x) / sim.scale;
          const dy = (midY - canvasMid.y) / sim.scale;
          sim.centerX = initialCenter.x - dx;
          sim.centerY = initialCenter.y - dy;
        }
      });
      
      canvas.addEventListener('touchend', (e) => {
        if(e.touches.length < 2) { isPinching = false; }
        if(e.touches.length === 0) { draggingIndex = null; draggingCamera = false; }
      });
      
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomFactor = Math.exp(e.deltaY * -0.001);
        sim.userScaleFactor *= zoomFactor;
        sim.userScaleFactor = Math.max(0.1, Math.min(5, sim.userScaleFactor));
        document.getElementById('scaleRange').value = sim.userScaleFactor;
        document.getElementById('scaleValor').textContent = sim.userScaleFactor;
        if(document.getElementById('trackSelect').value !== "global"){
          sim.targetScale = sim.userScaleFactor * sim.factorBase;
        } else {
          if(!sim.autoZoomEnabled){
            sim.targetScale = sim.userScaleFactor * sim.factorBase;
          }
        }
      });
      
      const config3Body = {
        lagrange: [
          { m: 1, x: 1, y: 0, vx: 0, vy: -0.577350269, color: "#FF0000" },
          { m: 1, x: -0.5, y: -0.866025404, vx: -0.5, vy: 0.288675134, color: "#00FF00" },
          { m: 1, x: -0.5, y: 0.866025404, vx: 0.5, vy: 0.288675134, color: "#0000FF" }
        ],
        figura8: [
          { m: 1, x: 0.97000436, y: 0.24308753, vx: -0.93240737/2, vy: -0.86473146/2, color: "#FF0000" },
          { m: 1, x: -0.97000436, y: -0.24308753, vx: 0.93240737/2, vy: 0.86473146/2, color: "#00FF00" },
          { m: 1, x: 0, y: 0, vx: 0, vy: 0, color: "#0000FF" }
        ],
        euler: [
          { m: 1, x: -1, y: 0, vx: 0, vy: 0.3, color: "#FF8800" },
          { m: 1, x: 0, y: 0, vx: 0, vy: -0.6, color: "#88FF00" },
          { m: 1, x: 1, y: 0, vx: 0, vy: 0.3, color: "#0088FF" }
        ],
        butterfly: [
          { m: 1, x: -1, y: 0, vx: 0.306893, vy: 0.125507, color: "#FF0000" },
          { m: 1, x: 1, y: 0, vx: 0.306893, vy: 0.125507, color: "#00FF00" },
          { m: 1, x: 0, y: 0, vx: -0.613786, vy: -0.251014, color: "#0000FF" }
        ],
        personalizada: [
          { m: 1, x: 0.5, y: 0, vx: 0, vy: 0.5, color: "#FFAA00" },
          { m: 1, x: -0.5, y: 0, vx: 0, vy: -0.5, color: "#00AABB" },
          { m: 1, x: 0, y: 0.5, vx: 0.5, vy: 0, color: "#AA00FF" }
        ]
      };
      const originalPersonalizada = JSON.parse(JSON.stringify(config3Body.personalizada));

      class Body {
        constructor(cfg) {
          this.m = cfg.m;
          this.x = cfg.x;
          this.y = cfg.y;
          this.vx = cfg.vx;
          this.vy = cfg.vy;
          this.ax = 0;
          this.ay = 0;
          this.color = cfg.color || "#FFFFFF";
          this.trail = [];
          this.trailLength = 600;
          this.radius = 0.02;
        }
        update(dt) {
          this.vx += this.ax * dt;
          this.vy += this.ay * dt;
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          const lastPoint = this.trail[this.trail.length - 1];
          if (!lastPoint || Math.hypot(this.x - lastPoint.x, this.y - lastPoint.y) > 0.01) {
            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > this.trailLength) { this.trail.shift(); }
          }
        }
        draw(ctx, scale, offsetX = 0, offsetY = 0) {
          if (this.trail.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.1;
            for (let i = 0; i < this.trail.length - 1; i++) {
              const alpha = (i / this.trail.length) * 0.8 + 0.2;
              ctx.globalAlpha = alpha;
              const x1 = (this.trail[i].x - offsetX) * scale;
              const y1 = (this.trail[i].y - offsetY) * scale;
              const x2 = (this.trail[i + 1].x - offsetX) * scale;
              const y2 = (this.trail[i + 1].y - offsetY) * scale;
              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.stroke();
            }
          }
          ctx.globalAlpha = 1;
          ctx.beginPath();
          ctx.fillStyle = this.color;
          const x = (this.x - offsetX) * scale;
          const y = (this.y - offsetY) * scale;
          ctx.arc(x, y, this.radius * scale, 0, 2 * Math.PI);
          ctx.fill();
          ctx.beginPath();
          ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.arc(x, y, this.radius * scale * 0.5, 0, 2 * Math.PI);
          ctx.fill();
        }
      }

      class Simulation {
        constructor() {
          this.bodies = [];
          this.dt = parseFloat(document.getElementById('dtRange').value);
          this.G = 1;
          this.factorBase = 200;
          this.userScaleFactor = parseFloat(document.getElementById('scaleRange').value);
          this.scale = this.userScaleFactor * this.factorBase;
          this.speed = parseFloat(document.getElementById('speedRange').value);
          this.paused = false;
          this.centerX = 0;
          this.centerY = 0;
          this.targetScale = this.scale;
          this._requiredGlobalScale = this.factorBase;
          this.autoZoomEnabled = true;
        }
        loadConfiguration(name) {
          if (name === "personalizada") {
            this.dt = 0.001;
            this.speed = 1;
            this.scale = this.factorBase;
            this.targetScale = this.scale;
            document.getElementById('dtRange').value = this.dt;
            document.getElementById('dtValor').textContent = this.dt;
            document.getElementById('scaleRange').value = (this.scale / this.factorBase);
            document.getElementById('scaleValor').textContent = (this.scale / this.factorBase);
            document.getElementById('speedRange').value = this.speed;
            document.getElementById('speedValor').textContent = this.speed;
            this.bodies = [...config3Body.personalizada].map(c => new Body(c));
          } else {
            this.dt = (name === "butterfly") ? 0.0005 : 0.001;
            this.speed = 1;
            this.scale = this.factorBase;
            this.targetScale = this.scale;
            document.getElementById('dtRange').value = this.dt;
            document.getElementById('dtValor').textContent = this.dt;
            document.getElementById('scaleRange').value = (this.scale/this.factorBase);
            document.getElementById('scaleValor').textContent = (this.scale/this.factorBase);
            document.getElementById('speedRange').value = this.speed;
            document.getElementById('speedValor').textContent = this.speed;
            this.bodies = config3Body[name].map(c => new Body(c));
            document.getElementById('extraInfo').innerHTML = (name === "butterfly") ?
              "<strong>Butterfly-1</strong><br>Solución de Šuvakov–Dmitrašinović." : "";
          }
          this.bodies.forEach(b => b.trail = []);
          actualizarListaCuerpos();
          actualizarTrackSelect();
          if (this.bodies.length > 0) {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (let b of this.bodies) {
              if (b.x < minX) minX = b.x;
              if (b.x > maxX) maxX = b.x;
              if (b.y < minY) minY = b.y;
              if (b.y > maxY) maxY = b.y;
            }
            this.centerX = (minX + maxX) / 2;
            this.centerY = (minY + maxY) / 2;
          }
        }
        computeForces() {
          for (let b of this.bodies) { b.ax = 0; b.ay = 0; }
          for (let i = 0; i < this.bodies.length; i++) {
            for (let j = i + 1; j < this.bodies.length; j++) {
              const dx = this.bodies[j].x - this.bodies[i].x;
              const dy = this.bodies[j].y - this.bodies[i].y;
              const r2 = dx * dx + dy * dy;
              const r = Math.sqrt(r2);
              const F = this.G / (r2 + 1e-6);
              this.bodies[i].ax += F * dx * this.bodies[j].m;
              this.bodies[i].ay += F * dy * this.bodies[j].m;
              this.bodies[j].ax -= F * dx * this.bodies[i].m;
              this.bodies[j].ay -= F * dy * this.bodies[i].m;
            }
          }
        }
        update() {
          // Actualizar la física solo si no está pausada.
          if (!this.paused) {
            for (let i = 0; i < this.speed; i++) {
              this.computeForces();
              for (let b of this.bodies) { b.update(this.dt); }
            }
          }
          // Actualizar el tracking de la cámara (siempre, incluso en pausa)
          const trackVal = document.getElementById('trackSelect').value;
          if (trackVal.startsWith("body")) {
            const idx = parseInt(trackVal.slice(4));
            if (this.bodies[idx]) {
              const targetX = this.bodies[idx].x;
              const targetY = this.bodies[idx].y;
              this.centerX += (targetX - this.centerX) * 0.1;
              this.centerY += (targetY - this.centerY) * 0.1;
            }
          } else if (trackVal === "global") {
            if (this.bodies.length > 0) {
              let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
              for (let b of this.bodies) {
                if (b.x < minX) minX = b.x;
                if (b.x > maxX) maxX = b.x;
                if (b.y < minY) minY = b.y;
                if (b.y > maxY) maxY = b.y;
              }
              const desiredCenterX = (minX + maxX) / 2;
              const desiredCenterY = (minY + maxY) / 2;
              this.centerX += (desiredCenterX - this.centerX) * 0.1;
              this.centerY += (desiredCenterY - this.centerY) * 0.1;
              const boundingWidth = maxX - minX;
              const boundingHeight = maxY - minY;
              const margin = 1.2;
              const requiredScale = Math.min(canvas.width, canvas.height) / (Math.max(boundingWidth, boundingHeight) * margin);
              this._requiredGlobalScale = requiredScale;
              if (this.autoZoomEnabled) {
                this.targetScale = requiredScale * this.userScaleFactor;
              } else {
                this.targetScale = this.userScaleFactor * this.factorBase;
              }
            }
          }
          // Actualizar la escala (zoom) siempre, incluso en pausa.
          this.scale += (this.targetScale - this.scale) * 0.1;
        }
        draw() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.save();
          ctx.translate(canvas.width/2, canvas.height/2);
          ctx.scale(1, -1);
          for (let b of this.bodies) { b.draw(ctx, this.scale, this.centerX, this.centerY); }
          ctx.restore();
        }
      }

      const sim = new Simulation();
      sim.loadConfiguration(document.getElementById('configSelect').value);

      function actualizarTrackSelect() {
        const trackSelect = document.getElementById('trackSelect');
        const oldVal = trackSelect.value;
        trackSelect.innerHTML = '<option value="none">Ninguno</option>';
        const opGlobal = document.createElement('option');
        opGlobal.value = "global";
        opGlobal.textContent = "Tracking Global";
        trackSelect.appendChild(opGlobal);
        sim.bodies.forEach((b, idx) => {
          const op = document.createElement('option');
          op.value = `body${idx}`;
          op.textContent = `Track cuerpo ${idx+1}`;
          trackSelect.appendChild(op);
        });
        if ([...trackSelect.options].some(o => o.value === oldVal)) {
          trackSelect.value = oldVal;
        } else { trackSelect.value = "none"; }
        const globalZoomContainer = document.getElementById('globalZoomToggleContainer');
        if (trackSelect.value === "global") { globalZoomContainer.style.display = "block"; }
        else { globalZoomContainer.style.display = "none"; }
      }

      function actualizarListaCuerpos() {
        const lista = document.getElementById('listaCuerpos');
        lista.innerHTML = "";
        sim.bodies.forEach((b, idx) => {
          const div = document.createElement('div');
          div.innerHTML = `<strong style="color: ${b.color};">Cuerpo ${idx+1}</strong>`;
          const masaDiv = document.createElement('div');
          masaDiv.className = "campo";
          masaDiv.innerHTML = `<label>Masa:</label>
            <input type="number" step="0.1" value="${b.m}">`;
          masaDiv.querySelector('input').addEventListener('change', function() { b.m = parseFloat(this.value); });
          div.appendChild(masaDiv);
          const vxDiv = document.createElement('div');
          vxDiv.className = "campo";
          vxDiv.innerHTML = `<label>Vel X:</label>
            <input type="number" step="0.1" value="${b.vx.toFixed(3)}">`;
          vxDiv.querySelector('input').addEventListener('change', function() { b.vx = parseFloat(this.value); });
          div.appendChild(vxDiv);
          const vyDiv = document.createElement('div');
          vyDiv.className = "campo";
          vyDiv.innerHTML = `<label>Vel Y:</label>
            <input type="number" step="0.1" value="${b.vy.toFixed(3)}">`;
          vyDiv.querySelector('input').addEventListener('change', function() { b.vy = parseFloat(this.value); });
          div.appendChild(vyDiv);
          const colorDiv = document.createElement('div');
          colorDiv.className = "campo";
          colorDiv.innerHTML = `<label>Color:</label>
            <input type="color" value="${b.color}">`;
          colorDiv.querySelector('input').addEventListener('change', function() {
            b.color = this.value;
            div.querySelector('strong').style.color = b.color;
          });
          div.appendChild(colorDiv);
          const pxDiv = document.createElement('div');
          pxDiv.className = "campo";
          pxDiv.innerHTML = `<label>Pos X:</label>
            <input type="number" step="0.1" value="${b.x.toFixed(3)}">`;
          pxDiv.querySelector('input').addEventListener('change', function() { b.x = parseFloat(this.value); b.trail = []; });
          div.appendChild(pxDiv);
          const pyDiv = document.createElement('div');
          pyDiv.className = "campo";
          pyDiv.innerHTML = `<label>Pos Y:</label>
            <input type="number" step="0.1" value="${b.y.toFixed(3)}">`;
          pyDiv.querySelector('input').addEventListener('change', function() { b.y = parseFloat(this.value); b.trail = []; });
          div.appendChild(pyDiv);
          const btnEliminar = document.createElement('button');
          btnEliminar.className = "btnEliminar";
          btnEliminar.textContent = "Eliminar";
          btnEliminar.addEventListener('click', () => {
            sim.bodies.splice(idx, 1);
            actualizarListaCuerpos();
            actualizarTrackSelect();
          });
          div.appendChild(btnEliminar);
          lista.appendChild(div);
        });
      }

      document.getElementById('btnRestablecer').addEventListener('click', () => {
        document.getElementById('configSelect').value = "personalizada";
        document.getElementById('dtRange').value = "0.001";
        document.getElementById('dtValor').textContent = "0.001";
        document.getElementById('scaleRange').value = "1";
        document.getElementById('scaleValor').textContent = "1";
        document.getElementById('speedRange').value = "1";
        document.getElementById('speedValor').textContent = "1";
        document.getElementById('trackSelect').value = "none";
        config3Body.personalizada = JSON.parse(JSON.stringify(originalPersonalizada));
        sim.loadConfiguration("personalizada");
        sim.centerX = 0;
        sim.centerY = 0;
        sim.userScaleFactor = 1;
        sim.scale = sim.userScaleFactor * sim.factorBase;
        sim.targetScale = sim.scale;
        sim.autoZoomEnabled = true;
        document.getElementById('btnToggleAutoZoom').textContent = "Desactivar Zoom Automático";
      });

      document.getElementById('btnPausar').addEventListener('click', () => {
        sim.paused = !sim.paused;
        document.getElementById('btnPausar').textContent = sim.paused ? "Reanudar" : "Pausar";
      });

      document.getElementById('btnReiniciar').addEventListener('click', () => {
        sim.loadConfiguration(document.getElementById('configSelect').value);
      });

      document.getElementById('configSelect').addEventListener('change', (e) => {
        sim.loadConfiguration(e.target.value);
      });

      document.getElementById('dtRange').addEventListener('input', (e) => {
        sim.dt = parseFloat(e.target.value);
        document.getElementById('dtValor').textContent = sim.dt;
      });

      document.getElementById('scaleRange').addEventListener('input', (e) => {
        sim.userScaleFactor = parseFloat(e.target.value);
        document.getElementById('scaleValor').textContent = e.target.value;
        if(document.getElementById('trackSelect').value !== "global"){
          sim.targetScale = sim.userScaleFactor * sim.factorBase;
        }
      });

      document.getElementById('speedRange').addEventListener('input', (e) => {
        sim.speed = parseFloat(e.target.value);
        document.getElementById('speedValor').textContent = e.target.value;
      });

      document.getElementById('trackSelect').addEventListener('change', () => {
        sim.bodies.forEach(b => b.trail = []);
        sim.centerX = 0;
        sim.centerY = 0;
        actualizarTrackSelect();
      });

      const btnToggleAutoZoom = document.getElementById('btnToggleAutoZoom');
      btnToggleAutoZoom.addEventListener('click', () => {
        sim.autoZoomEnabled = !sim.autoZoomEnabled;
        btnToggleAutoZoom.textContent = sim.autoZoomEnabled ? "Desactivar Zoom Automático" : "Activar Zoom Automático";
      });

      document.getElementById('btnInfo').addEventListener('click', () => {
        document.getElementById('infoModal').style.display = "block";
      });

      document.getElementById('btnCerrarInfo').addEventListener('click', () => {
        document.getElementById('infoModal').style.display = "none";
      });

      const formAgregar = document.getElementById('formAgregar');
      document.getElementById('btnAgregar').addEventListener('click', () => {
        formAgregar.style.display = "block";
      });

      document.getElementById('btnCancelarAgregar').addEventListener('click', () => {
        formAgregar.style.display = "none";
      });

      document.getElementById('btnConfirmarAgregar').addEventListener('click', () => {
        const m = parseFloat(document.getElementById('nuevaMasa').value);
        const vx = parseFloat(document.getElementById('nuevaVx').value);
        const vy = parseFloat(document.getElementById('nuevaVy').value);
        const x = parseFloat(document.getElementById('nuevoPosX').value);
        const y = parseFloat(document.getElementById('nuevoPosY').value);
        let color = document.getElementById('nuevoColor').value;
        if(color.toLowerCase() === "#ffffff") {
          color = "#" + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
        }
        const newBody = new Body({ m, x, y, vx, vy, color });
        config3Body.personalizada.push({ m, x, y, vx, vy, color });
        sim.bodies.push(newBody);
        actualizarListaCuerpos();
        actualizarTrackSelect();
        formAgregar.style.display = "none";
      });

      function animate() {
        sim.update();
        sim.draw();
        requestAnimationFrame(animate);
      }

      animate();
    })();
  </script>
</body>
</html>
